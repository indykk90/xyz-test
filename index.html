
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>HERE XYZ Studio: tourist map</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/codelab-elements/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14"></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  id="here-xyz-studio-tourist-map"
                  title="HERE XYZ Studio: tourist map"
                  environment="web"
                  feedback-link="">
    
      <google-codelab-step label="Introduction" duration="0">
        <h2 is-upgraded><strong>Introduction</strong></h2>
<p>This training was prepared to show functionalities of the HERE XYZ Studio. HERE XYZ Studio is an interactive, visual, web-based application for accessing XYZ Hub data and creating maps within minutes. This tutorial doesn&#39;t require coding skills.</p>
<p class="image-container"><img style="width: 624.00px" src="img\b87c70bee48c4acb.png"></p>
<h2 is-upgraded><strong>Training objectives</strong></h2>
<p>In this tutorial, you&#39;re going to build a tourist map for Central European countries: Baltics, Poland, Czech Republic, Slovakia and Hungary. This map will:</p>
<ul>
<li>Display borders of each country</li>
<li>Use your collections from wego.here.com</li>
<li>Allow to draw your dreamful places to visit in the future</li>
</ul>
<aside class="special"><p><strong>Useful materials:</strong></p>
<ul>
<li><a href="https://www.here.xyz/studio/" target="_blank">https://www.here.xyz/studio/</a></li>
<li><a href="https://www.here.xyz/cli/" target="_blank">https://www.here.xyz/cli/</a></li>
<li><a href="https://wego.here.com/" target="_blank">https://wego.here.com/</a></li>
</ul>
</aside>
<h2 class="checklist" is-upgraded><strong>What you&#39;ll learn</strong></h2>
<ul class="checklist">
<li>How to create an account in XYZ Studio</li>
<li>How to install HERE Data Hub CLI</li>
<li>How to add you spacial data to the project</li>
<li>How to add your collections from wego.here.com to the HERE XYZ Studio</li>
<li>Displaying data on a map</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Getting set up" duration="0">
        <h2 is-upgraded><strong>Create an account in HERE XYZ Studio</strong></h2>
<p>To create an account, please visit our site:</p>
<p><a href="https://xyz.here.com/studio/" target="_blank"><paper-button class="colored" raised>HERE XYZ Studio</paper-button></a></p>
<aside class="special"><p><strong>Note:</strong> If you already have an account on our website please login.</p>
</aside>
<h2 is-upgraded><strong>Install node.js</strong></h2>
<aside class="special"><p><strong>Note:</strong> In this tutorial we are going to upload Shapefiles, which are larger files than GeoJSON or CSV. To do so, we need to use Data Hub CLI. </p>
</aside>
<p>Node.js is required to install HERE CLI. To use it, you should have npm installed. The best way is to go to <a href="https://nodejs.org/" target="_blank">nodejs.org</a> and install the appropriate package for your system. Download the package and install it normally.</p>
<h2 is-upgraded><strong>Install HERE CLI</strong></h2>
<p>Install the latest version of HERE CLI with following command:</p>
<p><code>npm install -g @here/cli </code></p>
<p>Type it in Node.js command prompt.</p>
<h2 is-upgraded><strong>Configure HERE CLI</strong></h2>
<p>HERE CLI needs to have access to your projects to help you work with your data. For that, you need to log in using your HERE developer account. You only need to do this once for a project.</p>
<p><code>here configure account</code></p>
<p>When prompted, enter your email and password that you use in the HERE Developer portal.</p>
<aside class="special"><p><strong>Note:</strong> For more details visit <a href="https://www.here.xyz/cli/" target="_blank">https://www.here.xyz/cli/</a></p>
</aside>


      </google-codelab-step>
    
      <google-codelab-step label="Creating new project" duration="0">
        <h2 is-upgraded><strong>Create new project</strong></h2>
<p>When you first sign in you won&#39;t see any projects, so to create  a new one, click <strong>Create new project </strong>button or click on the circle icon with + inside (which is located below <strong>Create new icon</strong> button). </p>
<p class="image-container"><img style="width: 624.00px" src="img\d8f02f5cef8e79c6.png"></p>
<p>In the next  step you can give your map a name and also a description. </p>
<p class="image-container"><img style="width: 351.00px" src="img\ce5a50a48993da41.png"></p>
<p>In this step you can also pick a Base Map. Feel free to pick the one you like the most, there are a few available at the moment. We will go with one from the HERE group. Please, keep <strong>Show labels</strong> ticked.</p>
<p class="image-container"><img style="width: 624.00px" src="img\53c481845a3273af.png"></p>


      </google-codelab-step>
    
      <google-codelab-step label="Adding data to the project" duration="0">
        <p>There are two ways of adding spatial data to the project:</p>
<ul>
<li>Directly by HERE XYZ Studio</li>
<li>Using Data Hub CLI</li>
</ul>
<p>We are going to play with Shapefiles, so for this reason Data Hub CLI is required. </p>
<h2 is-upgraded><strong>Adding data by using Data Hub CLI</strong></h2>
<aside class="special"><p><strong>Note:</strong> For more information about Data Hub CLI, visit: <a href="https://developer.here.com/tutorials/using-the-xyz-cli/" target="_blank">https://developer.here.com/tutorials/using-the-xyz-cli/</a></p>
</aside>
<p>Tu bedzie  foto</p>


      </google-codelab-step>
    
      <google-codelab-step label="Provide a full offline experience" duration="9">
        <p>Take a moment and put your phone into airplane mode, and try running some of your favorite apps. In almost all cases, they provide a fairly robust offline experience. Users expect that robust experience from their apps. And the web should be no different. Progressive Web Apps should be designed with offline as a core scenario.</p>
<aside class="special"><p>Designing for offline-first can drastically improve the performance of your web app by reducing the number of network requests made by your app, instead resources can be precached and served directly from the local cache. Even with the fastest network connection, serving from the local cache will be faster!</p>
</aside>
<h2 is-upgraded><strong>Service worker life cycle</strong></h2>
<p>The life cycle of the service worker is the most complicated part. If you don&#39;t know what it&#39;s trying to do and what the benefits are, it can feel like it&#39;s fighting you. But once you know how it works, you can deliver seamless, unobtrusive updates to users, mixing the best of the web and native patterns.</p>
<aside class="special"><p><strong>Dive Deeper:</strong> This codelab only covers the very basics of the service worker life cycle. To dive deeper, refer to <a href="https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle" target="_blank">The Service Worker Lifecycle</a> article on WebFundamentals.</p>
</aside>
<h3 is-upgraded><strong><code>install</code></strong><strong> event</strong></h3>
<p>The first event a service worker gets is <code>install</code>. It&#39;s triggered as soon as the worker executes, and it&#39;s only called once per service worker. <strong>If you alter your service worker script the browser considers it a different service worker</strong>, and it&#39;ll get its own <code>install</code> event. </p>
<p class="image-container"><img style="width: 624.00px" src="img\e75a38479ab6742.png"></p>
<p>Typically the <code>install</code> event is used to cache everything you need for your app to run. </p>
<h3 is-upgraded><strong><code>activate</code></strong><strong> event</strong></h3>
<p>The service worker will receive an <code>activate</code> event every time it starts up. The main purpose of the <code>activate</code> event is to configure the service worker&#39;s behavior, clean up any resources left behind from previous runs (e.g. old caches), and get the service worker ready to handle network requests (for example the <code>fetch</code> event described below).</p>
<h3 is-upgraded><strong><code>fetch</code></strong><strong> event</strong></h3>
<p>The fetch event allows the service worker to intercept any network requests and handle requests. It can go to the network to get the resource, it can pull it from its own cache, generate a custom response or any number of different options. Check out the <a href="https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/" target="_blank">Offline Cookbook</a> for different strategies that you can use.</p>
<h3 is-upgraded><strong>Updating a service worker</strong></h3>
<p>The browser checks to see if there is a new version of your service worker on each page load. If it finds a new version, the new version is downloaded and installed in the background, but it is not activated. It&#39;s sits in a waiting state, until there are no longer any pages open that use the old service worker. Once all windows using the old service worker are closed, the new service worker is activated and can take control. Refer to the <a href="https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#updates" target="_blank">Updating the service worker</a> section of the Service Worker Lifecycle doc for further details.</p>
<h2 is-upgraded><strong>Choosing the right caching strategy</strong></h2>
<p>Choosing the right <a href="https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/" target="_blank">caching strategy</a> depends on the type of resource you&#39;re trying to cache and how you might need it later. For our weather app, we&#39;ll split the resources we need to cache into two categories: resources we want to precache and the data that we&#39;ll cache at runtime.</p>
<h3 is-upgraded><strong>Caching static resources</strong></h3>
<p>Precaching your resources is a similar concept to what happens when a user installs a desktop or mobile app. The key resources needed for the app to run are installed, or cached on the device so that they can be loaded later whether there&#39;s a network connection or not.</p>
<p>For our app, we&#39;ll precache all of our static resources when our service worker is installed so that everything we need to run our app is stored on the user&#39;s device. To ensure our app loads lightning fast, we&#39;ll use the <a href="https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-falling-back-to-network" target="_blank">cache-first</a> strategy; instead of going to the network to get the resources, they&#39;re pulled from the local cache; only if it&#39;s not available there will we try to get it from the network.</p>
<p class="image-container"><img style="width: 624.00px" src="img\5932a908f5a71ed2.png"></p>
<p>Pulling from the local cache eliminates any network variability. No matter what kind of network the user is on (WiFi, 5G, 3G, or even 2G), the key resources we need to run are available almost immediately.</p>
<aside class="warning"><p><strong>Caution:</strong> In this sample, static resources are served using a <a href="https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-falling-back-to-network" target="_blank"><code>cache-first</code></a> strategy, which results in a copy of any cached content being returned without consulting the network. While a <code>cache-first</code> strategy is easy to implement, it can cause challenges in the future.</p>
</aside>
<h3 is-upgraded><strong>Caching the app data</strong></h3>
<p>The <a href="https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#stale-while-revalidate" target="_blank">stale-while-revalidate strategy</a> is ideal for certain types of data and works well for our app. It gets data on screen as quickly as possible, then updates that once the network has returned the latest data. Stale-while-revalidate means we need to kick off two asynchronous requests, one to the cache and one to the network. </p>
<p class="image-container"><img style="width: 624.00px" src="img\96d80309bc4c9cd6.png"></p>
<p>Under normal circumstances, the cached data will be returned almost immediately providing the app with recent data it can use. Then, when the network request returns, the app will be updated using the latest data from the network.</p>
<p>For our app, this provides a better experience than the network, falling back to cache strategy because the user does not have to wait until the network request times out to see something on screen. They may initially see older data, but once the network request returns, the app will be updated with the latest data.</p>
<h2 is-upgraded><strong>Update app logic</strong></h2>
<p>As mentioned previously, the app needs to kick off two asynchronous requests, one to the cache and one to the network. The app uses the <code>caches</code> object available in <code>window</code> to access the cache and retrieve the latest data. This is an excellent example of progressive enhancement as the <code>caches</code> object may not be available in all browsers, and if it&#39;s not the network request should still work.</p>
<p>Update the <code>getForecastFromCache()</code> function, to check if the <code>caches</code> object is available in the global <code>window</code> object, and if it is, request the data from the cache.</p>
<h3 is-upgraded><a href="https://github.com/googlecodelabs/your-first-pwapp/blob/master/public/scripts/app.js#L164" target="_blank"><strong>public/scripts/app.js</strong></a></h3>
<pre><code>// CODELAB: Add code to get weather forecast from the caches object.
if (!(&#39;caches&#39; in window)) {
  return null;
}
const url = `${window.location.origin}/forecast/${coords}`;
return caches.match(url)
    .then((response) =&gt; {
      if (response) {
        return response.json();
      }
      return null;
    })
    .catch((err) =&gt; {
      console.error(&#39;Error getting data from cache&#39;, err);
      return null;
    });</code></pre>
<p>Then, we need to modify <a href="https://github.com/googlecodelabs/your-first-pwapp/blob/master/public/scripts/app.js#L196" target="_blank"><code>updateData()</code></a> so that it makes two calls, one to <code>getForecastFromNetwork()</code> to get the forecast from the network, and one to <code>getForecastFromCache()</code> to get the latest cached forecast:</p>
<h3 is-upgraded><a href="https://github.com/googlecodelabs/your-first-pwapp/blob/master/public/scripts/app.js#L200" target="_blank"><strong>public/scripts/app.js</strong></a></h3>
<pre><code>// CODELAB: Add code to call getForecastFromCache.
getForecastFromCache(location.geo)
    .then((forecast) =&gt; {
      renderForecast(card, forecast);
    });</code></pre>
<p>Our weather app now makes two asynchronous requests for data, one from the cache and one via a <code>fetch</code>. If there&#39;s data in the cache, it&#39;ll be returned and rendered extremely quickly (tens of milliseconds). Then, when the <code>fetch</code> responds, the card will be updated with the freshest data direct from the weather API.</p>
<p>Notice how the cache request and the <code>fetch</code> request both end with a call to update the forecast card. How does the app know whether it&#39;s displaying the latest data? This is handled in the following code from <code>renderForecast()</code>:</p>
<h3 is-upgraded><a href="https://github.com/googlecodelabs/your-first-pwapp/blob/master/public/scripts/app.js#L85" target="_blank"><strong>public/scripts/app.js</strong></a></h3>
<pre><code>// If the data on the element is newer, skip the update.
if (lastUpdated &gt;= data.currently.time) {
  return;
}</code></pre>
<p>Every time that a card is updated, the app stores the timestamp of the data on a hidden attribute on the card. The app just bails if the timestamp that already exists on the card is newer than the data that was passed to the function.</p>
<h2 is-upgraded><strong>Pre-cache our app resources</strong></h2>
<p>In the service worker, let&#39;s add a <code>DATA_CACHE_NAME</code> so that we can separate our applications data from the app shell. When the app shell is updated and older caches are purged, our data will remain untouched, ready for a super fast load. Keep in mind, if your data format changes in the future, you&#39;ll need a way to handle that and ensure the app shell and content stay in sync.</p>
<h3 is-upgraded><a href="https://github.com/googlecodelabs/your-first-pwapp/blob/master/public/service-worker.js#L21" target="_blank"><strong>public/service-worker.js</strong></a></h3>
<pre><code>// CODELAB: Update cache names any time any of the cached files change.
const CACHE_NAME = &#39;static-cache-v2&#39;;
const DATA_CACHE_NAME = &#39;data-cache-v1&#39;;</code></pre>
<p>Don&#39;t forget to also update the <code>CACHE_NAME</code>; we&#39;ll be changing all of our static resources as well.</p>
<p>In order for our app to work offline, we need to precache all of the resources it needs. This will also help our performance. Instead of having to get all of the resources from the network, the app will be able to load all of them from the local cache, eliminating any network instability.</p>
<p>Update the <code>FILES_TO_CACHE</code> array with the list of files:</p>
<h3 is-upgraded><a href="https://github.com/googlecodelabs/your-first-pwapp/blob/master/public/service-worker.js#L23" target="_blank"><strong>public/service-worker.js</strong></a></h3>
<pre><code>// CODELAB: Add list of files to cache here.
const FILES_TO_CACHE = [
  &#39;/&#39;,
  &#39;/index.html&#39;,
  &#39;/scripts/app.js&#39;,
  &#39;/scripts/install.js&#39;,
  &#39;/scripts/luxon-1.11.4.js&#39;,
  &#39;/styles/inline.css&#39;,
  &#39;/images/add.svg&#39;,
  &#39;/images/clear-day.svg&#39;,
  &#39;/images/clear-night.svg&#39;,
  &#39;/images/cloudy.svg&#39;,
  &#39;/images/fog.svg&#39;,
  &#39;/images/hail.svg&#39;,
  &#39;/images/install.svg&#39;,
  &#39;/images/partly-cloudy-day.svg&#39;,
  &#39;/images/partly-cloudy-night.svg&#39;,
  &#39;/images/rain.svg&#39;,
  &#39;/images/refresh.svg&#39;,
  &#39;/images/sleet.svg&#39;,
  &#39;/images/snow.svg&#39;,
  &#39;/images/thunderstorm.svg&#39;,
  &#39;/images/tornado.svg&#39;,
  &#39;/images/wind.svg&#39;,
];</code></pre>
<p>Since we are manually generating the list of files to cache, every time we update a file we <strong>must update the </strong><strong><code>CACHE_NAME</code></strong>. We were able to remove <code>offline.html</code> from our list of cached files because our app now has all the necessary resources it needs to work offline, and won&#39;t ever show the offline page again.</p>
<aside class="warning"><p><strong>Caution:</strong> In this sample, we hand-rolled our own service worker. Each time we update any of the static resources, we need to re-roll the service worker and update the cache, otherwise the old content will be served. In addition, when one file changes, the entire cache is invalidated and needs to be re-downloaded. That means fixing a simple single character spelling mistake will invalidate the cache and require everything to be downloaded again—not exactly efficient. <a href="https://developers.google.com/web/tools/workbox/" target="_blank">Workbox</a> handles this gracefully, by integrating it into your build process, only changed files will be updated, saving bandwidth for users and easier maintenance for you!</p>
</aside>
<h3 is-upgraded><strong>Update the activate event handler</strong></h3>
<p>To ensure our <code>activate</code> event doesn&#39;t accidentally delete our data, in the <code>activate</code> event of <code>service-worker.js</code>, replace <code>if (key !== CACHE_NAME) {</code> with:</p>
<h3 is-upgraded><strong>public/service-worker.js</strong></h3>
<pre><code>if (key !== CACHE_NAME &amp;&amp; key !== DATA_CACHE_NAME) {</code></pre>
<h3 is-upgraded><strong>Update the fetch event handler</strong></h3>
<p>We need to modify the service worker to intercept requests to the weather API and store their responses in the cache, so we can easily access them later. In the stale-while-revalidate strategy, we expect the network response to be the ‘source of truth&#39;, always providing us with the most recent information. If it can&#39;t, it&#39;s OK to fail because we&#39;ve already retrieved the latest cached data in our app.</p>
<p>Update the <code>fetch</code> event handler to handle requests to the data API separately from other requests.</p>
<h3 is-upgraded><a href="https://github.com/googlecodelabs/your-first-pwapp/blob/master/public/service-worker.js#L42" target="_blank"><strong>public/service-worker.js</strong></a></h3>
<pre><code>// CODELAB: Add fetch event handler here.
if (evt.request.url.includes(&#39;/forecast/&#39;)) {
  console.log(&#39;[Service Worker] Fetch (data)&#39;, evt.request.url);
  evt.respondWith(
      caches.open(DATA_CACHE_NAME).then((cache) =&gt; {
        return fetch(evt.request)
            .then((response) =&gt; {
              // If the response was good, clone it and store it in the cache.
              if (response.status === 200) {
                cache.put(evt.request.url, response.clone());
              }
              return response;
            }).catch((err) =&gt; {
              // Network request failed, try to get it from the cache.
              return cache.match(evt.request);
            });
      }));
  return;
}
evt.respondWith(
    caches.open(CACHE_NAME).then((cache) =&gt; {
      return cache.match(evt.request)
          .then((response) =&gt; {
            return response || fetch(evt.request);
          });
    })
);</code></pre>
<p>The code intercepts the request and checks if it is for a weather forecast. If it is, use <code>fetch</code> to make the request. Once the response is returned, open the cache, clone the response, store it in the cache, and return the response to the original requestor.</p>
<p>We need to remove the <code>evt.request.mode !== &#39;navigate&#39;</code> check because we want our service worker to handle all requests (including images, scripts, CSS files, etc), not just navigations. If we left that check in, only the HTML would be served from the service worker cache, everything else would be requested from the network.</p>
<h2 is-upgraded><strong>Try it out</strong></h2>
<p>The app should be completely offline-functional now. Refresh the page to ensure that you&#39;ve got the latest service worker installed, then save a couple of cities and press the refresh button on the app to get fresh weather data.  </p>
<p>Then go to the <strong>Cache Storage</strong> pane on the <strong>Application</strong> panel of DevTools. Expand the section and you should see the name of your static cache and data cache listed on the left-hand side. Opening the data cache should show the data stored for each city.</p>
<p class="image-container"><img style="width: 624.00px" src="img\f140a63f77da9a1e.png"></p>
<p>Then, open DevTools and switch to the Service Workers pane, and check the Offline checkbox, then try reloading the page, and then go offline and reload the page. </p>
<p>If you&#39;re on a fast network and want to see how weather forecast data is updated on a slow connection, set the <code>FORECAST_DELAY</code> property in <code>server.js</code> to <code>5000</code>. All requests to the forecast API will be delayed by 5000ms.</p>
<h2 is-upgraded><strong>Verify changes with Lighthouse</strong></h2>
<p>It&#39;s also a good idea to run Lighthouse again.</p>
<p><strong>SEO Audit</strong></p>
<ul>
<li><strong>✅ PASSED:</strong> Document has a meta description. </li>
</ul>
<p><strong>Progressive Web App Audit</strong></p>
<ul>
<li><strong>✅ PASSED:</strong> Current page responds with a 200 when offline.</li>
<li><strong>✅ PASSED: </strong><code>start_url</code> responds with a 200 when offline.</li>
<li><strong>✅ PASSED:</strong> Registers a service worker that controls page and <code>start_url.</code></li>
<li><strong>✅ PASSED:</strong> Web app manifest meets the installability requirements.</li>
<li><strong>✅ PASSED:</strong> Configured for a custom splash screen.</li>
<li><strong>✅ PASSED:</strong> Sets an address-bar theme color.</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Add install experience" duration="5">
        <p>When a Progressive Web App is installed, it looks and behaves like all of the other installed apps. It launches from the same place as other apps launch. It runs in an app without an address bar or other browser UI. And like all other installed apps, it&#39;s a top level app in the task switcher.</p>
<p class="image-container"><img style="width: 298.00px" src="img\a4954aa2ceb43ba3.png"></p>
<p>In Chrome, a Progressive Web App can either be installed through the three-dot context menu, or you can provide a button or other UI component to the user that will prompt them to install your app. </p>
<aside class="special"><p><strong>Tip:</strong> Since the install experience in Chrome&#39;s three-dot context menu is somewhat buried, we recommend that you provide some indication within your app to notify the user your app can be installed, and an install button to complete the install process.</p>
</aside>
<h2 is-upgraded><strong>Audit with Lighthouse</strong></h2>
<p>In order for a user to be able to install your Progressive Web App, it needs to meet <a href="https://developers.google.com/web/fundamentals/app-install-banners/#criteria" target="_blank">certain criteria</a>. The easiest way to check is to use Lighthouse and make sure it meets the installable criteria.</p>
<p class="image-container"><img style="width: 624.00px" src="img\3136dac18701946b.png"></p>
<p>If you&#39;re worked through this codelab, your PWA should already meet these criteria.</p>
<aside class="special"><p><strong>DevTip:</strong> For this section, enable the <strong>Bypass for network</strong> checkbox in the <strong>Service Workers</strong> pane of the <strong>Application</strong> panel in DevTools. When checked, requests bypass the service worker and are sent directly to the network. This simplifies our development process since we don&#39;t have to update our service worker while working through this section.</p>
</aside>
<h2 is-upgraded><strong>Add install.js to index.html</strong></h2>
<p>First, let&#39;s add the <code>install.js</code> to our <code>index.html</code> file.</p>
<h3 is-upgraded><a href="https://github.com/googlecodelabs/your-first-pwapp/blob/master/public/index.html#L204" target="_blank"><strong>public/index.html</strong></a></h3>
<pre><code>&lt;!-- CODELAB: Add the install script here --&gt;
&lt;script src=&#34;/scripts/install.js&#34;&gt;&lt;/script&gt;</code></pre>
<h2 is-upgraded><strong>Listen for </strong><strong><code>beforeinstallprompt</code></strong><strong> event</strong></h2>
<p>If the add to home screen <a href="https://developers.google.com/web/fundamentals/app-install-banners/#criteria" target="_blank">criteria</a> are met, Chrome will fire a <code>beforeinstallprompt</code> event, that you can use to indicate your app can be &#39;installed&#39;, and then prompt the user to install it. Add the code below to listen for the <code>beforeinstallprompt</code> event:</p>
<h3 is-upgraded><a href="https://github.com/googlecodelabs/your-first-pwapp/blob/master/public/scripts/install.js#L24" target="_blank"><strong>public/scripts/install.js</strong></a></h3>
<pre><code>// CODELAB: Add event listener for beforeinstallprompt event
window.addEventListener(&#39;beforeinstallprompt&#39;, saveBeforeInstallPromptEvent);</code></pre>
<h2 is-upgraded><strong>Save event and show install button</strong></h2>
<p>In our <code>saveBeforeInstallPromptEvent</code> function, we&#39;ll save a reference to the <code>beforeinstallprompt</code> event so that we can call <code>prompt()</code> on it later, and update our UI to show the install button.</p>
<h3 is-upgraded><a href="https://github.com/googlecodelabs/your-first-pwapp/blob/master/public/scripts/install.js#L34" target="_blank"><strong>public/scripts/install.js</strong></a></h3>
<pre><code>// CODELAB: Add code to save event &amp; show the install button.
deferredInstallPrompt = evt;
installButton.removeAttribute(&#39;hidden&#39;);</code></pre>
<h2 is-upgraded><strong>Show the prompt / hide the button</strong></h2>
<p>When the user clicks the install button, we need to call <code>.prompt()</code> on the saved <code>beforeinstallprompt</code> event. We also need to hide the install button, because <code>.prompt()</code> can only be called once on each saved event.</p>
<h3 is-upgraded><a href="https://github.com/googlecodelabs/your-first-pwapp/blob/master/public/scripts/install.js#L45" target="_blank"><strong>public/scripts/install.js</strong></a></h3>
<pre><code>// CODELAB: Add code show install prompt &amp; hide the install button.
deferredInstallPrompt.prompt();
// Hide the install button, it can&#39;t be called twice.
evt.srcElement.setAttribute(&#39;hidden&#39;, true);</code></pre>
<p>Calling <code>.prompt()</code> will show a modal dialog to the user, asking them to add your app to their home screen.</p>
<h2 is-upgraded><strong>Log the results</strong></h2>
<p>You can check to see how the user responded to the install dialog by listening for the promise returned by the <code>userChoice</code> property of the saved <code>beforeinstallprompt</code> event. The promise returns an object with an <code>outcome</code> property after the prompt has shown and the user has responded to it.</p>
<h3 is-upgraded><a href="https://github.com/googlecodelabs/your-first-pwapp/blob/master/public/scripts/install.js#L47" target="_blank"><strong>public/scripts/install.js</strong></a></h3>
<pre><code>// CODELAB: Log user response to prompt.
deferredInstallPrompt.userChoice
    .then((choice) =&gt; {
      if (choice.outcome === &#39;accepted&#39;) {
        console.log(&#39;User accepted the A2HS prompt&#39;, choice);
      } else {
        console.log(&#39;User dismissed the A2HS prompt&#39;, choice);
      }
      deferredInstallPrompt = null;
    });</code></pre>
<p>One comment about <code>userChoice</code>, the <a href="https://w3c.github.io/manifest/#beforeinstallpromptevent-interface" target="_blank">spec defines it as a property</a>, not a function as you might expect.</p>
<h3 is-upgraded><strong>Log all install events</strong></h3>
<p>In addition to any UI you add to install your app, users can also install your PWA through other methods, for example Chrome&#39;s three-dot menu. To track these events, listen for the appinstalled event.</p>
<h3 is-upgraded><a href="https://github.com/googlecodelabs/your-first-pwapp/blob/master/public/scripts/install.js#L51" target="_blank"><strong>public/scripts/install.js</strong></a></h3>
<pre><code>// CODELAB: Add event listener for appinstalled event
window.addEventListener(&#39;appinstalled&#39;, logAppInstalled);</code></pre>
<p>Then, we&#39;ll need to update the <code>logAppInstalled</code> function, for this codelab, we&#39;ll just use <code>console.log</code>, but in a production app, you probably want to log this as an event with your analytics software.</p>
<h3 is-upgraded><a href="https://github.com/googlecodelabs/your-first-pwapp/blob/master/public/scripts/install.js#L60" target="_blank"><strong>public/scripts/install.js</strong></a></h3>
<pre><code>// CODELAB: Add code to log the event
console.log(&#39;Weather App was installed.&#39;, evt);</code></pre>
<h2 is-upgraded><strong>Update the service worker</strong></h2>
<p>Don&#39;t forget to update the <code>CACHE_NAME</code> in your <code>service-worker.js</code> file since you&#39;ve made changes to files that are already cached. Enabling the <strong>Bypass for network</strong> checkbox in the Service Workers pane of the Application panel in DevTools will work in development, but won&#39;t help in the real world.</p>
<h2 is-upgraded><strong>Try it out</strong></h2>
<p>Let&#39;s see how our install step went. To be safe, use the <strong>Clear site data</strong> button in the Application panel of DevTools to clear everything away and make sure we&#39;re starting fresh. If you previously installed the app, be sure to uninstall it, otherwise the install icon won&#39;t show up again.</p>
<h3 is-upgraded><strong>Verify the install button is visible</strong></h3>
<p>First, let&#39;s verify our install icon shows up properly, be sure to try this on both desktop and mobile.</p>
<ol type="1" start="1">
<li>Open the URL in a new Chrome tab.</li>
<li>Open Chrome&#39;s three-dot menu (next to the address bar).<br>▢ Verify you see &#34;<em>Install Weather...</em>&#34; in the menu.</li>
<li>Refresh the weather data using the refresh button in the upper right corner to ensure we meet the <a href="https://developers.google.com/web/fundamentals/app-install-banners/#criteria" target="_blank">user engagement heuristics</a>.<br>▢ Verify the install icon is visible in the app header.</li>
</ol>
<h3 is-upgraded><strong>Verify the install button works</strong></h3>
<p>Next, let&#39;s make sure everything installs properly, and our events are properly fired. You can do this either on desktop or mobile. If you want to test this on mobile, be sure you&#39;re using remote debugging so you can see what&#39;s logged to the console. <br></p>
<ol type="1" start="1">
<li>Open Chrome, and in a new browser tab, navigate to your Weather PWA.</li>
<li>Open DevTools and switch to the Console pane.</li>
<li>Click the install button in the upper right corner.<br>▢ Verify the install button disappears<br>▢ Verify the install modal dialog is shown.</li>
<li>Click Cancel.<br>▢ Verify &#34;<em>User dismissed the A2HS prompt</em>&#34; is shown in the console output.<br>▢ Verify the install button reappears.</li>
<li>Click the install button again, then click the install button in the modal dialog.<br>▢ Verify &#34;<em>User accepted the A2HS prompt</em>&#34; is shown in the console output.<br>▢ Verify &#34;<em>Weather App was installed</em>&#34; is shown in the console output.<br>▢ Verify the Weather app is added to the place where you&#39;d typically find apps.</li>
<li>Launch the Weather PWA.<br>▢ Verify the app opens as a standalone app, either in an app window on desktop, or full screen on mobile.</li>
</ol>
<p>Note, if you&#39;re running on desktop from localhost, your installed PWA may show an address banner because localhost isn&#39;t considered a secure host.</p>
<h3 is-upgraded><strong>Verify iOS installation works properly</strong></h3>
<p>Let&#39;s also check the behavior on iOS. If you have an iOS device, you can use that, or if you&#39;re on a Mac, try the iOS Simulator available with Xcode.</p>
<ol type="1" start="1">
<li>Open Safari and in a new browser tab, navigate to your Weather PWA.</li>
<li>Click the <em>Share </em><img style="width: 19.00px" src="img\7fc386fd0954ef1b.png"> button.</li>
<li>Scroll right and click on the <em>Add to Home Screen</em> button.<br>▢ Verify the title, URL and icon are correct.</li>
<li>Click <em>Add.<br></em>▢ Verify the app icon is added to the home screen.</li>
<li>Launch the Weather PWA from the home screen.<br>▢ Verify the app launches full screen.</li>
</ol>
<h2 is-upgraded><strong>Bonus: Detecting if your app is launched from the home screen</strong></h2>
<p>The <code>display-mode</code> media query makes it possible to apply styles depending on how the app was launched, or determine how it was launched with JavaScript. </p>
<pre><code>@media all and (display-mode: standalone) {
  body {
    background-color: yellow;
  }
}</code></pre>
<p>You can also check the <code>display-mode</code> media query in <a href="https://developers.google.com/web/fundamentals/app-install-banners/#detect-mode" target="_blank">JavaScript to see if you&#39;re running in standalone</a>.</p>
<h2 is-upgraded><strong>Bonus: Uninstalling your PWA</strong></h2>
<p>Remember, the <code>beforeinstallevent</code> doesn&#39;t fire if the app is already installed, so during development you&#39;ll probably want to install and uninstall your app several times to make sure everything is working as expected.</p>
<h3 is-upgraded><strong>Android</strong></h3>
<p>On Android, PWAs are uninstalled in the same way other installed apps are uninstalled.</p>
<ul>
<li>Open the app drawer.</li>
<li>Scroll down to find the Weather icon.</li>
<li>Drag the app icon to the top of the screen.</li>
<li>Choose <em>Uninstall.</em></li>
</ul>
<h3 is-upgraded><strong>ChromeOS</strong></h3>
<p>On ChromeOS, PWAs are easily uninstalled from the launcher search box.</p>
<ul>
<li>Open the launcher.</li>
<li>Type &#34;<em>Weather</em>&#34; into the search box, your Weather PWA should appear in the results.</li>
<li>Right click (alt-click) on the Weather PWA.</li>
<li>Click <em>Remove from Chrome...</em></li>
</ul>
<h3 is-upgraded><strong>macOS and Windows</strong></h3>
<p>On Mac and Windows, PWAs may be uninstalled through Chrome:</p>
<ul>
<li>In a new browser tab, open <em>chrome://apps</em>.</li>
<li>Right click (alt-click) on the Weather PWA.</li>
<li>Click <em>Remove from Chrome...</em></li>
</ul>
<p>You can also open the installed PWA, click the the dot menu in the upper right corner, and choose &#34;<em>Uninstall Weather PWA...</em>&#34;</p>


      </google-codelab-step>
    
      <google-codelab-step label="Congratulations" duration="0">
        <p>Congratulations, you&#39;ve successfully built your first Progressive Web App! </p>
<p>You added a web app manifest to enable it to be installed, and you added a service worker to ensure that your PWA is always fast, and reliable. You learned how to use DevTools to audit an app and how it can help you improve your user experience.</p>
<p>You now know the key steps required to turn any web app into a Progressive Web App.</p>
<h2 is-upgraded><strong>What&#39;s next?</strong></h2>
<p>Check out some of these codelabs...</p>
<ul>
<li><a href="https://codelabs.developers.google.com/codelabs/push-notifications/index.html" target="_blank">Adding Push Notifications to a Web App</a></li>
<li><a href="https://codelabs.developers.google.com/codelabs/debugging-service-workers/index.html" target="_blank">Debugging Service Workers</a></li>
<li><a href="https://codelabs.developers.google.com/codelabs/workbox-lab/index.html" target="_blank">Build a PWA using Workbox</a></li>
</ul>
<h2 is-upgraded><strong>Further reading</strong></h2>
<ul>
<li><a href="https://developers.google.com/web/fundamentals/primers/service-workers/high-performance-loading" target="_blank">High-performance service worker loading</a></li>
<li><a href="https://medium.com/dev-channel/service-worker-caching-strategies-based-on-request-types-57411dd7652c" target="_blank">Service Worker Caching Strategies Based on Request Types</a></li>
</ul>
<h2 is-upgraded><strong>Reference docs</strong></h2>
<ul>
<li><a href="https://developers.google.com/web/fundamentals/web-app-manifest" target="_blank">Web App Manifest docs</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/Manifest#Members" target="_blank">Web App Manifest properties (MDN)</a></li>
<li><a href="https://developers.google.com/web/fundamentals/app-install-banners/" target="_blank">Install &amp; Add to Home Screen</a></li>
<li><a href="https://developers.google.com/web/fundamentals/primers/service-workers/" target="_blank">Service Worker Overview</a></li>
<li><a href="https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle" target="_blank">Service Worker Lifecycle</a></li>
<li><a href="https://developers.google.com/web/fundamentals/primers/service-workers/high-performance-loading" target="_blank">High-performance service worker loading</a></li>
<li><a href="https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#generic-fallback" target="_blank">Offline Cookbook</a></li>
</ul>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/codelab-elements/native-shim.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/prettify.js"></script>
  <script src="https://storage.googleapis.com/codelab-elements/codelab-elements.js"></script>

</body>
</html>
